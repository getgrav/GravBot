'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));

function deattribute() {
  return _deattribute.apply(this, arguments);
}

function _deattribute() {
  return _deattribute = _asyncToGenerator(function* (data) {
    return 'object' === typeof data && null !== data && (Array.isArray(data) ? yield data.map(function () {
      var _ref = _asyncToGenerator(function* (el) {
        return deattribute(el);
      });

      return function () {
        return _ref.apply(this, arguments);
      };
    }()) : data.attributes && data.attributes.constructor === Object && (Object.keys(data.attributes).forEach(key => {
      data[key] = data.attributes[key];
    }), delete data.attributes)), data;
  }), _deattribute.apply(this, arguments);
}

function error(E) {
  if (E.response) {
    const e = E.response.data;
    e && e.errors && (E.errors = e.errors);
  }

  throw E;
}

function filterIncludes() {
  return _filterIncludes.apply(this, arguments);
}

function _filterIncludes() {
  return _filterIncludes = _asyncToGenerator(function* (included, {
    id,
    type
  }) {
    try {
      const filtered = included.filter(el => el.id === id && el.type === type)[0] || {
        id,
        type
      };
      return Object.assign({}, filtered);
    } catch (E) {
      error(E);
    }
  }), _filterIncludes.apply(this, arguments);
}

function link() {
  return _link.apply(this, arguments);
}

function _link() {
  return _link = _asyncToGenerator(function* ({
    id,
    type,
    meta
  }, included) {
    const filtered = yield filterIncludes(included, {
      id,
      type
    });
    return filtered.relationships && (yield linkRelationships(filtered, included)), meta && (filtered.meta = meta), deattribute(filtered);
  }), _link.apply(this, arguments);
}

function linkArray() {
  return _linkArray.apply(this, arguments);
}

function _linkArray() {
  return _linkArray = _asyncToGenerator(function* (data, included, key) {
    data[key] = [];

    var _iteratorNormalCompletion = !0,
        _didIteratorError = !1,
        _iteratorError = void 0;

    try {
      for (var _step, _iterator = (yield data.relationships[key].data)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        let resource = _step.value;
        data[key].push((yield link(resource, included)));
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        _iteratorNormalCompletion || null == _iterator.return || _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
  }), _linkArray.apply(this, arguments);
}

function linkObject() {
  return _linkObject.apply(this, arguments);
}

function _linkObject() {
  return _linkObject = _asyncToGenerator(function* (data, included, key) {
    data[key] = yield link(data.relationships[key].data, included), delete data[key].relationships;
  }), _linkObject.apply(this, arguments);
}

function linkRelationships() {
  return _linkRelationships.apply(this, arguments);
}

function _linkRelationships() {
  return _linkRelationships = _asyncToGenerator(function* (data, included) {
    const relationships = data.relationships;
    let removeRelationships = !1;

    for (let key in yield relationships) relationships[key].data && Array.isArray(relationships[key].data) ? (yield linkArray(data, included, key), removeRelationships = !0) : relationships[key].data && (yield linkObject(data, included, key), removeRelationships = !0);

    return removeRelationships && delete data.relationships, data;
  }), _linkRelationships.apply(this, arguments);
}

function deserialiseArray() {
  return _deserialiseArray.apply(this, arguments);
}

function _deserialiseArray() {
  return _deserialiseArray = _asyncToGenerator(function* (obj) {
    var _iteratorNormalCompletion = !0,
        _didIteratorError = !1,
        _iteratorError = void 0;

    try {
      for (var _step, _iterator = (yield obj.data)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        let value = _step.value;
        obj.included && (value = yield linkRelationships(value, obj.included)), value.attributes && (value = yield deattribute(value)), obj.data[obj.data.indexOf(value)] = value;
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        _iteratorNormalCompletion || null == _iterator.return || _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }

    return obj;
  }), _deserialiseArray.apply(this, arguments);
}

function deserialise() {
  return _deserialise.apply(this, arguments);
}

function _deserialise() {
  return _deserialise = _asyncToGenerator(function* (obj) {
    return obj.data && obj.data.constructor === Array ? obj = yield deserialiseArray(obj) : obj.included && (obj.data = yield linkRelationships(obj.data, obj.included)), delete obj.included, obj.data && obj.data.attributes && (obj.data = yield deattribute(obj.data)), obj;
  }), _deserialise.apply(this, arguments);
}

function queryFormat(value, key) {
  return null !== value && 'object' === typeof value ? query(value, key) : encodeURIComponent(key) + '=' + encodeURIComponent(value);
}

function query(params, prefix = null) {
  const str = [];

  for (const param in params) params.hasOwnProperty(param) && str.push(queryFormat(params[param], prefix ? `${prefix}[${param}]` : param));

  return str.join('&');
}

const requiresID = (method, key) => `${method} requires an ID for the ${key} relationships`;

function isValid() {
  return _isValid.apply(this, arguments);
}

function _isValid() {
  return _isValid = _asyncToGenerator(function* (obj, method, type) {
    if (obj.constructor !== Object || 0 === Object.keys(obj).length) throw new Error(`${method} requires a JSON object body`);
    if ('POST' !== method && !obj.id) throw new Error(`${method} requires an ID for the ${type} type`);
  }), _isValid.apply(this, arguments);
}

function serialiseObject() {
  return _serialiseObject.apply(this, arguments);
}

function _serialiseObject() {
  return _serialiseObject = _asyncToGenerator(function* (node, nodeType, key, data, method) {
    if ('string' !== typeof node.id) throw new Error(requiresID(method, key));
    return data.relationships || (data.relationships = {}), node.type || (node.type = nodeType), data.relationships[key] = {
      data: Object.assign(node)
    }, data;
  }), _serialiseObject.apply(this, arguments);
}

function serialiseArray() {
  return _serialiseArray.apply(this, arguments);
}

function _serialiseArray() {
  return _serialiseArray = _asyncToGenerator(function* (node, nodeType, key, data, method) {
    return data.relationships || (data.relationships = {}), data.relationships[key] = {
      data: node.map(({
        id,
        type
      }) => {
        if (!id) throw new Error(requiresID(method, key));
        return {
          id,
          type: type || nodeType
        };
      })
    }, data;
  }), _serialiseArray.apply(this, arguments);
}

function serialiseAttr() {
  return _serialiseAttr.apply(this, arguments);
}

function _serialiseAttr() {
  return _serialiseAttr = _asyncToGenerator(function* (node, key, data) {
    return data.attributes || (data.attributes = {}), data.attributes[key] = node, data;
  }), _serialiseAttr.apply(this, arguments);
}

function serialise() {
  return _serialise.apply(this, arguments);
}

function _serialise() {
  return _serialise = _asyncToGenerator(function* (model, obj = {}, method = 'POST') {
    try {
      const type = this.plural(this.camel(model));
      let data = {
        type
      };

      for (let key in yield isValid(obj, method, type), 'POST' !== method && (data.id = obj.id + ""), obj) {
        const node = obj[key],
              nodeType = this.plural(this.camel(key));
        null !== node & node.constructor === Object ? data = yield serialiseObject(node, nodeType, key, data, method) : null !== node && Array.isArray(node) ? data = yield serialiseArray(node, nodeType, key, data, method) : 'id' !== key && 'type' !== key && (data = yield serialiseAttr(node, key, data));
      }

      return {
        data
      };
    } catch (E) {
      throw error(E);
    }
  }), _serialise.apply(this, arguments);
}

var index = (s => s.replace(/[-_][a-z\u00E0-\u00F6\u00F8-\u00FE]/g, match => match.slice(1).toUpperCase()));

var index$1 = (s => s.charAt(0).toLowerCase() + s.slice(1).replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '-' + match.toLowerCase()));

var index$2 = (s => s.charAt(0).toLowerCase() + s.slice(1).replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '_' + match.toLowerCase()));

exports.camel = index;
exports.kebab = index$1;
exports.snake = index$2;
exports.deattribute = deattribute;
exports.deserialise = deserialise;
exports.error = error;
exports.filterIncludes = filterIncludes;
exports.linkRelationships = linkRelationships;
exports.query = query;
exports.serialise = serialise;
